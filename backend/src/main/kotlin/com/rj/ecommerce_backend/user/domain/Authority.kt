package com.rj.ecommerce_backend.user.domain // Assuming this is the target package for domain entities

import jakarta.persistence.*
import org.hibernate.annotations.CreationTimestamp
import org.hibernate.annotations.UpdateTimestamp
import org.springframework.data.annotation.CreatedBy
import org.springframework.data.annotation.LastModifiedBy
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.LocalDateTime

@Entity
@Table(name = "authorities")
@EntityListeners(AuditingEntityListener::class)
// Using a regular class because 'users' collection in equals/hashCode generated by data class
// can cause issues (LazyInitializationException, performance, circular dependencies).
// We'll override them manually for ID-based or natural key-based equality.
class Authority(
    @Column(nullable = false, unique = true)
    var name: String, // Non-nullable, assuming authority name is mandatory

    // Initialize collections directly. 'val' as the reference to the set won't change.
    // The set should contain non-nullable User entities.
    @ManyToMany(mappedBy = "authorities", fetch = FetchType.LAZY) // Added LAZY fetch
    val users: MutableSet<User> = mutableSetOf()

    // Auditing fields are not typically part of the primary constructor
    // as they are managed by the framework.
) {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null // Nullable because it's generated

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    var createdAt: LocalDateTime? = null

    @UpdateTimestamp
    @Column(nullable = false)
    var updatedAt: LocalDateTime? = null

    @CreatedBy
    @Column(updatable = false)
    var createdBy: String? = null

    @LastModifiedBy
    var lastModifiedBy: String? = null

    // No-arg constructor for JPA (generated by kotlin-jpa plugin if class is @Entity,
    // or can be added manually if not using the plugin: constructor() : this(name = "DEFAULT_NAME_INIT_ONLY")
    // However, with 'name' being non-nullable in primary constructor, kotlin-jpa plugin is best.
    // If not using plugin, 'name' would need a default or be nullable.
    // Given 'name' is unique and non-nullable, it implies it's set upon creation.

    // --- Methods for managing bidirectional relationship (optional but good practice) ---
    fun addUser(user: User) {
        users.add(user)
        // Assuming User entity has an 'authorities' collection and an 'addAuthority' method
        // user.authorities.add(this) // Or user.addAuthority(this)
    }

    fun removeUser(user: User) {
        users.remove(user)
        // user.authorities.remove(this) // Or user.removeAuthority(this)
    }

    // --- equals, hashCode, toString ---
    // It's crucial for JPA entities to have proper equals/hashCode,
    // especially if they are part of collections or used in Sets.
    // Often based on 'id' if persisted, or a business key (like 'name' here) if not.

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Authority) return false // More Kotlin-idiomatic check also handling null

        // If IDs are present and non-zero, use ID for equality.
        // Otherwise, if entities are transient, use a natural business key (e.g., 'name').
        return if (id != null && id != 0L && other.id != null && other.id != 0L) {
            id == other.id
        } else {
            name == other.name // Fallback to name if IDs are not set/reliable
        }
    }

    override fun hashCode(): Int {
        // Consistent with equals: use ID if available, otherwise use the natural key.
        return if (id != null && id != 0L) {
            id.hashCode()
        } else {
            name.hashCode()
        }
    }

    override fun toString(): String {
        // Avoid including collections like 'users' in toString to prevent LazyInitializationException
        // and overly verbose output.
        return "Authority(id=$id, name='$name')"
    }
}